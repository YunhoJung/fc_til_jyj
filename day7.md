#Day 7 과제
###1) Stash
`stash`란 수정 중에 브랜치를 변경하거나, 잠시 멈춰야 하는 경우에 (그러나 커밋을 하기엔 좀 그럴 때) 임시적으로 저장하는 스택 공간으로 현재 워킹 디렉토리 내의 모든 수정 사항들을 저장해준다.

* `git stash` 혹은 뒤에 `save`까지 추가하면 스택에 stash가 추가된다.
* `git stash list`로 현재 스택 공간의 stash를 확인할 수 있다.
* `git stash apply` 뒤에 리스트에 나온 이름을 기입하여 적용할 수 있다. 만일 그냥 쓸 경우 가장 최근에 저장된 것을 꺼내온다.

git은 stash에 저장할 때 수정했던 파일들을 복원해준다. 다만 꼭 같은 브랜치일 필요는 없다. 다른 브랜치에서도 작업 내용을 불러올 수 있으며, stash 외의 수정 파일들이 존재해도 불러올 수 있다. 만약 충돌이 있을 경우 알려준다.

* stash를 적용할 때 staged 상태의 파일들을 다시 stage 해주진 않는다. 그래서 불러오는 중간에 `--index` 옵션으로 스테이지 상태도 적용해줘야 한다.
* `apply`는 단순히 불러오는 것 뿐이다. 여전히 스택에는 stash가 남아있으니 `git stash drop`을 이용해 제거해줘야 한다. 또한 `drop` 대신 `pop`을 사용할 수 있는데, 말 그대로 꺼냄과 동시에 제거해 준다.
* stash는 추적 중인 파일만 저장해준다. 만일 함께 하고 싶다면 명령 옵션으로 `--include-untracked`나 `-u`를 붙여주면 된다.
* `--patch`를 사용하면 대화형 프롬프트가 뜨며, stash에 저장할 것과 그러지 않을 것을 지정할 수 있다.

####stash branch
stash에 저장한 내용과 브랜치의 내용이 달라져 충돌이 일어날 수 있다. 그럴 때면 stash branch를 만들어 테스트를 해보면 된다. `git stash branch`를 실행하면 그 당시의 커밋에 체크아웃 한 뒤에 새로운 브랜치를 만들고 그곳에 적용한다. 또한 모든 것이 성공하면 stash를 삭제한다. 즉 stash를 하나의 브랜치화 한다고 보면 된다.

> 가끔 작업 파일들을 stash 하지 않고 밀어버리고 싶다면 `git clean`을 사용하면 된다. 이 때 추적하지 않은 모든 파일들은 제거되며, 되돌릴 수 없으니 신중하게 해야 한다.
> `git stash --all`을 이용하면 비슷한 효과를 내지만 stash함으로 안전하다.
> `-n`을 붙이면 가상으로 실행해보고 어떤 파일들이 지워질지 알려준다.
> 또한 `.gitignore`에 지정된 형식들은 무시된다. 이는 `-x`를 이용하면 적용할 수 있다.

###2) 검색
git에서는 저장된 코드나 커밋에서 원하는 부분을 빠르고 쉽게 검색하는 도구가 여러가지 있다.

* `grep` 명령은 커밋 트리의 내용이나 워킹 디렉토리의 내용을 문자열, 정규표현식으로 쉽게 찾아볼 수 있다.
	* `grep`에는 다양한 옵션이 있다. [참조](https://git-scm.com/book/ko/v2/Git-%EB%8F%84%EA%B5%AC-%EA%B2%80%EC%83%89) 
* `log (찾을 값)`을 이용하면 언제 변경되었는지 알 수 있다. 역시 다양한 옵션이 있으니 위의 링크를 참조하자.

###3) 히스토리 단장
코드를 짤 때도 스파게티 코드가 아닌 보기 쉽고 깔끔하게 작성해야 협업에 유리하듯이 git의 커밋 히스토리 역시 난잡한 것보단 깔끔한 편이 더 좋다. 다음은 커밋 히스토리를 단장하는 방법이다.

####마지막 커밋 수정
마지막 커밋 수정은 기본적이고 가장 자주하는 히스토리 단장이다. 커밋 메시지를 수정하거나, 파일 목록을 수정할 수 있다.

`git commit --amend`를 입력하면 자동으로 텍스트 편집기로 마지막 커밋 메시지를 보여준다. 그곳에서 수정이 가능하다.

커밋한 후에 새로 만든 파일이나 수정한 파일을 가장 최근 커밋에 넣고자 해도 `--amend`를 쓰면 된다. 이미 커밋을 했어도 스테이지에 있는 파일들을 마지막 커밋에 집어넣어준다. 이때 sha-1 값이 바뀌기에 과거의 커밋을 변경할 때 주의해야 하며, rebase 같이 이미 push한 커밋은 수정하면 안 된다.

####메시지를 여러개 수정하기
최근 커밋이 아닌 예전 커밋을 수정하려먼 다른 도구가 필요하다. 히스토리를 수정하기 위해 만들어진 도구는 없지만 `rebase`를 이용하면 수정할 수 있다. 현재 브랜치에서 커밋들을 하나씩 수정하는 것이 아니라 어느 시점부터 HEAD까지의 커밋을 한번에 Rebase한다.
* 대화형 모드로 진행하려면 `-i`옵션을 달면 된다.
* `HEAD~$`를 이용해 변경할 범위를 정할 수도 있다. $ 안엔 숫자를 넣으면 된다.

####순서 바꾸기
대화형 rebase 도구로 커밋 전체를 삭제하거나 순서를 조정할 수 있다. 앞서 범위를 지정하여 리베이스를 사용할 경우 텍스트 편집기가 뜨고, 수정할 범위의 커밋들이 나온다. 이 커밋들을 삭제하거나 이름을 바꿀 수 있으며, 이를 응용하면 순서 역시 바꿀 수 있다.

####합치기
역시 대화형 리베이스로 여러 개의 커밋을 하나로 만들 수도 있다. 리베이스 스크립트 내에 자동 포함된 도움말에 설명이 있는데, `pick`이나 `edit`말고 `squash`를 입력하면 Git은 해당 커밋과 바로 이전 커밋을 합칠 것이고 커밋 메시지도 Merge 한다.
> 스크립트 내부의 순서는 역순이다. 즉 맨 위가 오래된 커밋이다.
편집기를 종료하면 git은 merge를 위한 에디터 역시 자동으로 실행해준다.

####분리하기
커밋을 분리한다는 것은 기존의 커밋을 해제하고 스테이지를 여러 개로 분리, 원하는 만큼 다시 커밋하는 것이다. 해당 커밋을 리베이스 스크립트를 실행한 뒤 `edit`으로 지정해놓으면 커밋이 해제된다. 이제 그 내용을 다시 두 개로 나눠서 커밋하면 된다.

커밋이 모두 끝나면 `git rebase --continue`라는 명령을 실행하여 남은 리베이스 작업을 끝마칠 수 있다.

> 결코 push한 내용은 수정하지 말자. 혼란이 올 수 있다.

####아예 포크레인으로 밀어버리자
수정 사항이 너무 많아서 리베이스 스크립트론 어려울 것 같다면 `filter-branch`를 이용하자. 이 명령어는 히스토리 전체에서 필요한 것만 골라내는 도구다.

* 모든 커밋에서 파일 제거
	* 실수로 커밋한 파일이 있을 때, `git filter-branch --tree-filter 'rm f 파일 이름' HEAD`를 이용해 지울 수 있다. 이때 --tree-filter는 프로젝트를 체크아웃 한 후에 각 커밋에 명시한 명령을 실행시키고 그 결과를 다시 커밋한다. 즉 모든 커밋에 파일 이름에 해당하는 것들을 제거하라는 명령을 뿌려주는 것이다.
	* `filter-branch`에 `--all`을 추가하면 모든 브랜치에 적용할 수 있다.
* 하위 디렉토리를 루트 디렉토리로 만들기
	* 다른 VCS를 임포트할 경우 그 VCS만을 위한 디렉토리가 있을 수 있다. 그럴 때면 특정 폴더를 프로젝트의 루트 디렉토리로 만들어야 하는데 `--subdirectory-filter 파일이름 HEAD`을 이용하면 된다.
* 모든 커밋의 이메일 주소 수정하기
	*`--commit-filter`을 이용하면 된다.

###4) Reset 정확히 알기
`reset`과 `checkout`은 상당히 많은 기능을 지녀서 사용자를 헷갈리게 한다. 먼저 다음 개념을 알고 가자.

* HEAD : 마지막 커밋의 스냅샷이자 현재 브랜치를 가리키는 포인터.
* Index : 바로 다음에 커밋할 'staging area'
* 워킹 디렉토리 : 샌드박스

`reset`명령은 간단하게 위 세개의 트리를 조작한다.
* 1 단계. HEAD 이동
체크아웃처럼 브랜치를 옮기는 것이 아니라 현재 브랜치가 가리키는 커밋을 바꾼다.
* 2 단계. Index 업데이트
이동한 HEAD가 위치한 커밋의 내용으로 인덱스를 업데이트한다. 기본적인 리셋 명령어는 여기까지만 진행한다.
* 3 단계. 워킹 디렉토리 업데이트
만일 `-hard` 옵션을 추가했다면 이 단계까지 온다. 현재의 워킹 디렉토리의 파일들 역시 인덱스 처럼 업데이트해버린다. 이는 파일을 직접 변경한다는 말이다. 상당히 위험한 명령어다.

리셋에는 경로를 지정할 수 있다. 이땐 1단계가 건너뛰어진다. `git reset 파일명`은 인덱스의 스테이징 상태만 변경하기에 `git add 파일명`과 정확히 반대되는 격이다.

####체크아웃
체크아웃 역시 리셋처럼 위의 세 트리를 조작한다. 리셋은 헤드가 가리키는 브랜치를 움직이지만(작업하던 브랜치 내부에서 변경됨) 체크아웃은 헤드 자체를 다른 브랜치로 옮겨버린다.

체크아웃에 파일 경로를 줬을 경우 리셋처럼 헤드가 움직이지 않는다. 다만 리셋과는 달리 인덱스의 내용이 해당 커밋 버전으로 변경될 뿐만 아니라 워킹 디렉토리의 파일 역시 변한다.